#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
智能专家特征提取器，能够从PDF中学习专家思路并动态调整规则
"""

import json
import os
import re
import numpy as np
from typing import Dict, List, Tuple, Any, Optional
from collections import defaultdict, Counter
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score, accuracy_score

# 修复导入路径
try:
    from train.utils.feature.expert_feature import ExpertFeatureExtractor
except ImportError:
    import sys
    sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))
    from train.utils.feature.expert_feature import ExpertFeatureExtractor

class SmartExpertFeatureExtractor(ExpertFeatureExtractor):
    def __init__(self, rules_path: str = None, weights_path: str = None, performance_path: str = None):
        super().__init__()
        self.rules_path = rules_path or os.path.join(os.path.dirname(__file__), '../../data/expert_rules.json')
        self.weights_path = weights_path or os.path.join(os.path.dirname(__file__), '../../data/rule_weights.json')
        self.performance_path = performance_path or os.path.join(os.path.dirname(__file__), '../../data/rule_performance.json')
        self.rules_model_path = os.path.join(os.path.dirname(__file__), '../../data/rules_model.json')
        self.extracted_rules = []  # 存储从PDF提取的规则
        self.rule_weights = {}  # 规则权重
        self.rule_performance = {}  # 规则性能记录
        self.structured_rules = []  # 结构化规则表示
        self.weight_history = {}  # 权重变化历史记录
        
        # 初始化时提取规则
        self._extract_rules_from_pdf()
        # 加载或训练规则模型
        self._load_or_train_rules_model()
    
    def _extract_rules_from_pdf(self):
        """
        从PDF中提取专家规则（改进版）
        """
        # 模拟从PDF提取的规则（实际应用中应使用PDF解析库）
        pdf_rules = [
            "规则1：当主胜赔率低于1.6且主队主场胜率超过60%时，主胜概率极高",
            "规则2：当平赔在3.0-3.5之间且两队近期交锋平局率超过30%时，平局可能性大",
            "规则3：当负赔低于2.2且客队客场胜率超过50%时，客胜可能性高",
            "规则4：威廉希尔平赔率低于3.2且两队状态相近时，平局概率增加",
            "规则5：立博胜赔率变化超过0.3时，比赛结果确定性增加",
            "规则6：近5场比赛主队胜率超过70%且主胜赔率低于2.0时，主胜可期",
            "规则7：当主胜赔率在1.5-1.7之间且主队主场胜率超过75%时，主胜概率极高",
            "规则8：当两队近期交锋中主胜占比超过60%且主胜赔率低于2.2时，主胜可能性大",
            "规则9：当负赔低于2.0且客队客场连续3场不败时，客胜概率极大",
            "规则10：当主胜赔率高于3.0且主队近期3场不胜时，主胜概率极低",
            "规则11：当平赔高于3.8且两队攻击力都很强时，平局概率极低",
            "规则12：当立博和威廉希尔的主胜赔率差超过0.5时，冷门概率增加",
            "规则13：当主队近期防守端连续5场不失球且主胜赔率低于2.5时，主胜可期",
            "规则14：当客队近期进攻端连续3场进球且负赔低于2.8时，客胜可能性大",
            "规则15：当主胜赔率在1.8-2.2之间且两队实力相近时，比赛结果确定性高",
            "规则16：当主队近期战绩411且主胜赔率低于2.0时，主胜概率高",
            "规则17：当客队近期战绩321且负赔低于2.5时，客胜可能性大",
            "规则18：当两队近期战绩均为222且平赔在3.2-3.5之间时，平局概率增加",
            "规则19：当主队近期战绩501且主胜赔率低于1.8时，主胜概率极高",
            "规则20：当客队近期战绩1011且负赔低于2.2时，客胜概率极高"
        ]
        
        self.extracted_rules = pdf_rules
        
        # 解析规则为结构化格式
        self.structured_rules = []
        for i, rule_text in enumerate(pdf_rules, 1):
            structured_rule = self._parse_rule_to_structured(rule_text, i)
            if structured_rule:
                self.structured_rules.append(structured_rule)
    
    def _parse_rule_to_structured(self, rule_text: str, rule_id: int) -> Dict[str, Any]:
        """
        将规则文本解析为结构化格式
        
        参数:
            rule_text: 规则文本
            rule_id: 规则ID
            
        返回:
            dict: 结构化规则
        """
        structured_rule = {
            'id': f'rule_{rule_id}',
            'raw_text': rule_text,
            'conditions': [],
            'conclusion': {},
            'type': 'prediction'  # 默认规则类型
        }
        
        # 提取条件部分
        match = re.search(r'当(.*?)时，(.*)', rule_text)
        if not match:
            # 尝试另一种格式：没有"时，"的情况
            match = re.search(r'(.*?)(主胜|平局|客胜|负)(.*)', rule_text)
            if match:
                conditions_text = match.group(1)
                conclusion_text = match.group(2) + match.group(3)
            else:
                # 无法解析的规则格式
                return structured_rule
        else:
            conditions_text = match.group(1)
            conclusion_text = match.group(2)
        
        # 解析条件
        structured_rule['conditions'] = self._parse_conditions(conditions_text)
        
        # 解析结论
        structured_rule['conclusion'] = self._parse_conclusion(conclusion_text)
        
        # 确定规则类型
        if '极高' in conclusion_text or '极低' in conclusion_text:
            structured_rule['type'] = 'strong_prediction'
        elif '可能性大' in conclusion_text or '可期' in conclusion_text:
            structured_rule['type'] = 'prediction'
        else:
            structured_rule['type'] = 'general'
        
        return structured_rule

    def _parse_conditions(self, conditions_text: str) -> List[Dict[str, Any]]:
        """
        解析条件文本为结构化条件列表
        
        参数:
            conditions_text: 条件文本
            
        返回:
            list: 结构化条件列表
        """
        conditions = []
        
        # 分割条件（处理'且'连接的多个条件）
        condition_parts = re.split(r'且|或', conditions_text)
        
        for part in condition_parts:
            part = part.strip()
            if not part:
                continue
            
            # 解析赔率条件
            odds_match = re.search(r'(主胜|平|负)赔(?:率)?(低于|高于|在|超过)([\d.]+(?:-[\d.]+)?)', part)
            if odds_match:
                odds_type = odds_match.group(1)
                operator = odds_match.group(2)
                value = odds_match.group(3)
                
                condition = {
                    'type': 'odds',
                    'odds_type': odds_type,
                    'operator': operator,
                    'value': value
                }
                conditions.append(condition)
                continue
            
            # 解析胜率条件
            win_rate_match = re.search(r'([主队|客队|两队]+)(主场|客场|近期交锋|近期)?(胜率|不败率|平局率)(低于|高于|超过)([\d.]+)%', part)
            if win_rate_match:
                team = win_rate_match.group(1)
                location = win_rate_match.group(2) or '近期'
                rate_type = win_rate_match.group(3)
                operator = win_rate_match.group(4)
                value = float(win_rate_match.group(5)) / 100
                
                condition = {
                    'type': 'win_rate',
                    'team': team,
                    'location': location,
                    'rate_type': rate_type,
                    'operator': operator,
                    'value': value
                }
                conditions.append(condition)
                continue
            
            # 解析战绩格式条件（如411表示4胜1平1负，321表示3胜2平1负）
            # 支持两种格式："主队近期战绩411"和"两队近期战绩均为222"
            record_match = re.search(r'([主队|客队|两队]+)(近期|近[\d]+场)?战绩(?:均为)?([\d]{2,4})', part)
            if record_match:
                team = record_match.group(1)
                period = record_match.group(2) or '近期'
                record_str = record_match.group(3)
                
                # 解析战绩数字，按顺序胜平负
                if len(record_str) == 3:
                    wins = int(record_str[0])
                    draws = int(record_str[1])
                    losses = int(record_str[2])
                    total = wins + draws + losses
                elif len(record_str) == 4:
                    # 处理如1011（10胜1平1负）的情况
                    if record_str[0] in ['1', '2'] and record_str[1].isdigit():
                        wins = int(record_str[:2])
                        draws = int(record_str[2])
                        losses = int(record_str[3])
                        total = wins + draws + losses
                    else:
                        # 其他4位数字情况，按前两位胜，后两位平负
                        wins = int(record_str[:2])
                        draws = int(record_str[2])
                        losses = int(record_str[3])
                        total = wins + draws + losses
                else:
                    continue
                
                condition = {
                    'type': 'recent_record',
                    'team': team,
                    'period': period,
                    'wins': wins,
                    'draws': draws,
                    'losses': losses,
                    'total': total
                }
                conditions.append(condition)
                continue
            
            # 解析状态条件
            state_match = re.search(r'([主队|客队|两队]+)近期(进攻端|防守端)?连续([\d]+)场(胜|平|负|进球|不失球|不败)', part)
            if state_match:
                team = state_match.group(1)
                aspect = state_match.group(2) or '整体'
                count = int(state_match.group(3))
                result = state_match.group(4)
                
                condition = {
                    'type': 'recent_state',
                    'team': team,
                    'aspect': aspect,
                    'count': count,
                    'result': result
                }
                conditions.append(condition)
                continue
            
            # 解析赔率变化条件
            odds_change_match = re.search(r'(立博|威廉希尔)?(主胜|平|负)赔(率)?变化(超过|低于)([\d.]+)', part)
            if odds_change_match:
                bookmaker = odds_change_match.group(1) or '所有'
                odds_type = odds_change_match.group(2)
                operator = odds_change_match.group(4)
                value = float(odds_change_match.group(5))
                
                condition = {
                    'type': 'odds_change',
                    'bookmaker': bookmaker,
                    'odds_type': odds_type,
                    'operator': operator,
                    'value': value
                }
                conditions.append(condition)
                continue
            
            # 解析赔率差异条件
            odds_diff_match = re.search(r'(立博|威廉希尔)和(立博|威廉希尔)的(主胜|平|负)赔(率)?差(超过|低于)([\d.]+)', part)
            if odds_diff_match:
                bookmaker1 = odds_diff_match.group(1)
                bookmaker2 = odds_diff_match.group(2)
                odds_type = odds_diff_match.group(3)
                operator = odds_diff_match.group(5)
                value = float(odds_diff_match.group(6))
                
                condition = {
                    'type': 'odds_diff',
                    'bookmakers': [bookmaker1, bookmaker2],
                    'odds_type': odds_type,
                    'operator': operator,
                    'value': value
                }
                conditions.append(condition)
                continue
            
            # 其他条件
            conditions.append({
                'type': 'other',
                'text': part
            })
        
        return conditions

    def _match_recent_record_condition(self, condition: Dict[str, Any], team_state_data: Dict[str, Any]) -> float:
        """
        匹配近期战绩条件
        
        参数:
            condition: 近期战绩条件
            team_state_data: 球队状态数据
            
        返回:
            float: 条件匹配度 0-1
        """
        team = condition['team']
        target_wins = condition['wins']
        target_draws = condition['draws']
        target_losses = condition['losses']
        target_total = condition['total']
        
        # 获取对应球队的近期战绩
        if team == '主队':
            recent_form = team_state_data['home_team']['recent_form']
        elif team == '客队':
            recent_form = team_state_data['away_team']['recent_form']
        else:
            # 两队战绩取平均值
            home_form = team_state_data['home_team']['recent_form']
            away_form = team_state_data['away_team']['recent_form']
            recent_form = {
                'wins': (home_form.get('wins', 0) + away_form.get('wins', 0)) / 2,
                'draws': (home_form.get('draws', 0) + away_form.get('draws', 0)) / 2,
                'losses': (home_form.get('losses', 0) + away_form.get('losses', 0)) / 2,
                'total': (home_form.get('total', 0) + away_form.get('total', 0)) / 2
            }
        
        # 获取实际战绩
        actual_wins = recent_form.get('wins', 0)
        actual_draws = recent_form.get('draws', 0)
        actual_losses = recent_form.get('losses', 0)
        actual_total = recent_form.get('total', 0)
        
        # 归一化到相同的比赛数量
        if actual_total == 0:
            return 0.0
        
        # 将目标战绩按比例缩放到实际比赛数量
        scale_factor = actual_total / target_total
        scaled_target_wins = target_wins * scale_factor
        scaled_target_draws = target_draws * scale_factor
        scaled_target_losses = target_losses * scale_factor
        
        # 计算各项匹配度
        wins_match = max(0.0, 1.0 - abs(actual_wins - scaled_target_wins) / max(1, actual_wins + scaled_target_wins))
        draws_match = max(0.0, 1.0 - abs(actual_draws - scaled_target_draws) / max(1, actual_draws + scaled_target_draws))
        losses_match = max(0.0, 1.0 - abs(actual_losses - scaled_target_losses) / max(1, actual_losses + scaled_target_losses))
        
        # 计算综合匹配度（加权平均）
        match_score = (wins_match * 0.5 + draws_match * 0.25 + losses_match * 0.25)
        
        return match_score

    def _match_odds_condition(self, condition: Dict[str, Any], win_odds: float, draw_odds: float, lose_odds: float) -> float:
        """
        匹配赔率条件
        
        参数:
            condition: 赔率条件
            win_odds: 主胜赔率
            draw_odds: 平局赔率
            lose_odds: 客胜赔率
            
        返回:
            float: 条件匹配度 0-1
        """
        # 获取对应赔率
        if condition['odds_type'] == '主胜':
            current_odds = win_odds
        elif condition['odds_type'] == '平':
            current_odds = draw_odds
        elif condition['odds_type'] == '负':
            current_odds = lose_odds
        else:
            return 0.0
        
        # 解析条件值
        value = condition['value']
        if '-' in value:
            # 处理范围值
            min_val, max_val = map(float, value.split('-'))
            if condition['operator'] == '在':
                if min_val <= current_odds <= max_val:
                    # 完全匹配范围返回1.0，接近范围返回较高分数
                    return 1.0
                else:
                    # 计算与范围的距离
                    distance = min(abs(current_odds - min_val), abs(current_odds - max_val))
                    return max(0.0, 1.0 - distance / 1.0)
            else:
                return 0.0
        else:
            # 处理单一值
            target_value = float(value)
            operator = condition['operator']
            
            if operator == '低于' or operator == '超过':
                if operator == '低于' and current_odds < target_value:
                    # 差距越大，匹配度越高
                    gap = target_value - current_odds
                    return min(1.0, gap / 2.0 + 0.5)
                elif operator == '超过' and current_odds > target_value:
                    gap = current_odds - target_value
                    return min(1.0, gap / 2.0 + 0.5)
                else:
                    return 0.0
            else:
                return 0.0
    
    def _match_win_rate_condition(self, condition: Dict[str, Any], team_state_data: Dict[str, Any]) -> float:
        """
        匹配胜率条件
        
        参数:
            condition: 胜率条件
            team_state_data: 球队状态数据
            
        返回:
            float: 条件匹配度 0-1
        """
        team = condition['team']
        location = condition['location']
        rate_type = condition['rate_type']
        operator = condition['operator']
        target_value = condition['value']
        
        # 获取对应胜率
        current_rate = 0.0
        if team == '主队':
            if location == '主场':
                current_rate = team_state_data['home_team']['recent_form']['win_rate']
            elif location == '近期交锋':
                current_rate = team_state_data['home_team']['head_to_head']['win_rate']
            else:
                current_rate = team_state_data['home_team']['recent_form']['win_rate']
        elif team == '客队':
            if location == '客场':
                current_rate = team_state_data['away_team']['recent_form']['win_rate']
            elif location == '近期交锋':
                current_rate = team_state_data['away_team']['head_to_head']['win_rate']
            else:
                current_rate = team_state_data['away_team']['recent_form']['win_rate']
        elif team == '两队':
            if rate_type == '平局率' and location == '近期交锋':
                current_rate = team_state_data['home_team']['head_to_head']['draw_rate']
            else:
                # 两队平均胜率
                home_rate = team_state_data['home_team']['recent_form']['win_rate']
                away_rate = team_state_data['away_team']['recent_form']['win_rate']
                current_rate = (home_rate + away_rate) / 2
        
        # 判断条件
        if operator == '高于' or operator == '超过':
            if current_rate > target_value:
                gap = current_rate - target_value
                return min(1.0, gap / 0.3 + 0.5)
            else:
                return 0.0
        elif operator == '低于':
            if current_rate < target_value:
                gap = target_value - current_rate
                return min(1.0, gap / 0.3 + 0.5)
            else:
                return 0.0
        else:
            return 0.0
    
    def _match_recent_state_condition(self, condition: Dict[str, Any], team_state_data: Dict[str, Any]) -> float:
        """
        匹配近期状态条件
        
        参数:
            condition: 近期状态条件
            team_state_data: 球队状态数据
            
        返回:
            float: 条件匹配度 0-1
        """
        team = condition['team']
        aspect = condition['aspect']
        count = condition['count']
        result = condition['result']
        
        # 获取对应球队的近期状态
        if team == '主队':
            recent_form = team_state_data['home_team']['recent_form']
        elif team == '客队':
            recent_form = team_state_data['away_team']['recent_form']
        else:
            # 两队状态取平均值
            home_form = team_state_data['home_team']['recent_form']
            away_form = team_state_data['away_team']['recent_form']
            recent_form = {
                'win_streak': min(home_form['win_streak'], away_form['win_streak']),
                'unbeaten_streak': min(home_form['unbeaten_streak'], away_form['unbeaten_streak']),
                'scoring_streak': min(home_form['scoring_streak'], away_form['scoring_streak']),
                'clean_sheet_streak': min(home_form['clean_sheet_streak'], away_form['clean_sheet_streak'])
            }
        
        # 判断状态
        if result == '胜':
            streak = recent_form.get('win_streak', 0)
        elif result == '不败':
            streak = recent_form.get('unbeaten_streak', 0)
        elif result == '进球':
            streak = recent_form.get('scoring_streak', 0)
        elif result == '不失球':
            streak = recent_form.get('clean_sheet_streak', 0)
        else:
            return 0.0
        
        if streak >= count:
            # 连续场次越多，匹配度越高
            return min(1.0, streak / count)
        else:
            return 0.0
    
    def _match_odds_change_condition(self, condition: Dict[str, Any], odds_data: Dict[str, Any]) -> float:
        """
        匹配赔率变化条件
        
        参数:
            condition: 赔率变化条件
            odds_data: 赔率数据
            
        返回:
            float: 条件匹配度 0-1
        """
        bookmaker = condition['bookmaker']
        odds_type = condition['odds_type']
        operator = condition['operator']
        target_change = condition['value']
        
        # 获取对应赔率的变化
        change = 0.0
        if odds_type == '主胜':
            change = self._calculate_odds_change(odds_data, 'win', bookmaker)
        elif odds_type == '平':
            change = self._calculate_odds_change(odds_data, 'draw', bookmaker)
        elif odds_type == '负':
            change = self._calculate_odds_change(odds_data, 'lose', bookmaker)
        
        # 判断变化是否符合条件
        if operator == '超过' and abs(change) > target_change:
            # 变化越大，匹配度越高
            return min(1.0, abs(change) / (target_change * 2))
        elif operator == '低于' and abs(change) < target_change:
            return min(1.0, 1.0 - abs(change) / target_change)
        else:
            return 0.0
    
    def _match_odds_diff_condition(self, condition: Dict[str, Any], odds_data: Dict[str, Any]) -> float:
        """
        匹配赔率差异条件
        
        参数:
            condition: 赔率差异条件
            odds_data: 赔率数据
            
        返回:
            float: 条件匹配度 0-1
        """
        bookmaker1, bookmaker2 = condition['bookmakers']
        odds_type = condition['odds_type']
        operator = condition['operator']
        target_diff = condition['value']
        
        # 获取对应赔率
        odds1 = self._get_bookmaker_odds(odds_data, odds_type, bookmaker1)
        odds2 = self._get_bookmaker_odds(odds_data, odds_type, bookmaker2)
        
        if odds1 is None or odds2 is None:
            return 0.0
        
        # 计算赔率差
        odds_diff = abs(odds1 - odds2)
        
        # 判断差异是否符合条件
        if operator == '超过' and odds_diff > target_diff:
            return min(1.0, odds_diff / (target_diff * 2))
        elif operator == '低于' and odds_diff < target_diff:
            return min(1.0, 1.0 - odds_diff / target_diff)
        else:
            return 0.0
    
    def _calculate_odds_change(self, odds_data: Dict[str, Any], odds_type: str, bookmaker: str = '所有') -> float:
        """
        计算赔率变化
        
        参数:
            odds_data: 赔率数据
            odds_type: 赔率类型 ('win', 'draw', 'lose')
            bookmaker: 博彩公司
            
        返回:
            float: 赔率变化值（负数表示赔率降低，正数表示赔率升高）
        """
        # 简单实现：计算最新赔率与平均赔率的差异
        latest_odds = odds_data['latest'][odds_type]
        average_odds = sum(odds_data['history'].values()) / len(odds_data['history'])
        
        return latest_odds - average_odds
    
    def _get_bookmaker_odds(self, odds_data: Dict[str, Any], odds_type: str, bookmaker: str) -> Optional[float]:
        """
        获取特定博彩公司的赔率
        
        参数:
            odds_data: 赔率数据
            odds_type: 赔率类型
            bookmaker: 博彩公司
            
        返回:
            float: 赔率值，若不存在则返回None
        """
        # 简单实现：返回最新赔率
        return odds_data['latest'][odds_type]
    
    def _get_representative_odds(self, odds_data: Dict[str, Any]) -> Tuple[float, float, float]:
        """
        获取代表性赔率
        
        参数:
            odds_data: 赔率数据
            
        返回:
            tuple: (主胜赔率, 平局赔率, 客胜赔率)
        """
        return (
            odds_data['latest']['win'],
            odds_data['latest']['draw'],
            odds_data['latest']['lose']
        )
    
    def extract_expert_features(self, match_data: Dict[str, Any]) -> Dict[str, float]:
        """
        提取专家特征（改进版）
        
        参数:
            match_data: 比赛数据
            
        返回:
            dict: 专家特征
        """
        # 获取基础专家特征
        expert_features = super().extract_expert_features(match_data)
        
        # 获取比赛数据
        odds_data = match_data['odds']
        team_state_data = match_data['team_state']
        
        # 匹配规则到当前比赛
        rule_matches = []
        total_match_score = 0.0
        max_match_score = 0.0
        rule_match_scores = {}
        
        for rule in self.structured_rules:
            match_score = self._match_rule_to_context(rule, odds_data, team_state_data)
            if match_score > 0.1:  # 匹配阈值
                rule_matches.append(rule)
                total_match_score += match_score
                max_match_score = max(max_match_score, match_score)
                rule_match_scores[rule['raw_text']] = match_score
        
        # 计算智能专家特征
        smart_features = {
            'smart_expert_factor': 0.5,  # 默认值
            'relevant_rules_count': len(rule_matches),
            'total_match_score': total_match_score,
            'max_match_score': max_match_score,
            'weighted_match_score': 0.0,
            'prediction_rules_count': 0,
            'warning_rules_count': 0,
            'adjustment_rules_count': 0,
            'average_confidence': 0.0
        }
        
        # 计算加权匹配分数
        if rule_matches:
            weighted_score = 0.0
            total_weight = 0.0
            prediction_count = 0
            warning_count = 0
            adjustment_count = 0
            total_confidence = 0.0
            
            for rule in rule_matches:
                weight = self.rule_weights[rule['raw_text']]
                match_score = rule_match_scores[rule['raw_text']]
                weighted_score += weight * match_score
                total_weight += weight
                total_confidence += rule['conclusion']['confidence']
                
                # 统计规则类型
                if rule['type'] == 'prediction' or rule['type'] == 'strong_prediction':
                    prediction_count += 1
                elif rule['type'] == 'strong_warning':
                    warning_count += 1
                elif rule['type'] == 'adjustment':
                    adjustment_count += 1
            
            smart_features['weighted_match_score'] = weighted_score / total_weight
            smart_features['prediction_rules_count'] = prediction_count
            smart_features['warning_rules_count'] = warning_count
            smart_features['adjustment_rules_count'] = adjustment_count
            smart_features['average_confidence'] = total_confidence / len(rule_matches)
        
        # 更新智能版pdf专家因素
        smart_features['smart_expert_factor'] = self._calculate_smart_expert_factor(smart_features)
        
        # 更新专家特征
        expert_features.update(smart_features)
        
        # 计算并添加信心评分
        confidence_score = self._calculate_confidence_score(expert_features, odds_data, team_state_data)
        expert_features['expert_confidence_score'] = confidence_score
        
        return expert_features
    
    def _calculate_smart_expert_factor(self, smart_features: Dict[str, float]) -> float:
        """
        计算智能专家因素
        
        参数:
            smart_features: 智能特征
            
        返回:
            float: 智能专家因素
        """
        # 基础分数
        base_score = smart_features['weighted_match_score']
        
        # 根据相关规则数量调整
        if smart_features['relevant_rules_count'] == 0:
            return 0.5
        elif smart_features['relevant_rules_count'] >= 3:
            base_score *= 1.1
        
        # 根据规则类型调整
        if smart_features['prediction_rules_count'] > 0:
            base_score *= 1.05
        elif smart_features['warning_rules_count'] > 0:
            base_score *= 1.02
        
        # 根据平均置信度调整
        base_score *= smart_features['average_confidence']
        
        # 归一化到0-1范围
        return max(0.0, min(1.0, base_score))
    
    def _calculate_confidence_score(self, expert_features: Dict[str, float], odds_data: Dict[str, Any], 
                                   team_state_data: Dict[str, Any]) -> float:
        """
        计算专家分析的信心评分
        
        参数:
            expert_features: 专家特征
            odds_data: 赔率数据
            team_state_data: 球队状态数据
            
        返回:
            float: 信心评分 0-1
        """
        # 计算专家分析相关性
        is_relevant, relevance_score = self._is_expert_analysis_relevant(odds_data, team_state_data)
        
        # 基础信心分数
        base_confidence = expert_features['smart_expert_factor']
        
        # 根据相关性调整
        confidence_score = base_confidence * relevance_score
        
        # 考虑赔率匹配度
        win_odds, draw_odds, lose_odds = self._get_representative_odds(odds_data)
        home_win_rate = team_state_data['home_team']['recent_form']['win_rate']
        
        # 计算赔率与球队状态的匹配度
        expected_home_win = 1.0 / win_odds * 0.9
        odds_state_match = 1.0 - abs(expected_home_win - home_win_rate)
        
        # 调整信心评分
        confidence_score = (confidence_score * 0.7 + odds_state_match * 0.3)
        
        # 考虑历史交锋记录
        head_to_head = team_state_data['home_team']['head_to_head']
        if head_to_head['total_matches'] > 5:
            # 如果历史交锋记录丰富，增加信心
            confidence_score *= 1.05
        
        # 归一化
        return max(0.0, min(1.0, confidence_score))
    
    def _extract_pdf_expert_factor(self, match_data: Dict[str, Any]) -> float:
        """
        提取PDF专家因素（改进版）
        
        参数:
            match_data: 比赛数据
            
        返回:
            float: PDF专家因素
        """
        # 获取比赛数据
        odds_data = match_data['odds']
        team_state_data = match_data['team_state']
        
        # 匹配规则到当前比赛
        total_score = 0.0
        matched_rules = 0
        
        for rule in self.structured_rules:
            match_score = self._match_rule_to_context(rule, odds_data, team_state_data)
            if match_score > 0.3:  # 匹配阈值
                weight = self.rule_weights[rule['raw_text']]
                total_score += match_score * weight
                matched_rules += 1
        
        # 计算专家因素
        if matched_rules == 0:
            return 0.5  # 默认值
        
        expert_factor = total_score / matched_rules
        
        # 归一化到0-1范围
        return max(0.0, min(1.0, expert_factor))
    
    def update_rule_performance(self, match_result: Dict[str, Any]):
        """
        更新规则性能
        
        参数:
            match_result: 比赛结果数据
        """
        # 简单实现：记录规则性能
        if 'applied_rules' in match_result:
            for rule_text, result in match_result['applied_rules'].items():
                if rule_text not in self.rule_performance:
                    self.rule_performance[rule_text] = {
                        'correct': 0,
                        'total': 0,
                        'history': []
                    }
                
                is_correct = result == match_result['actual_result']
                self.rule_performance[rule_text]['total'] += 1
                if is_correct:
                    self.rule_performance[rule_text]['correct'] += 1
                
                # 记录历史记录
                self.rule_performance[rule_text]['history'].append({
                    'match_id': match_result['match_id'],
                    'predicted': result,
                    'actual': match_result['actual_result'],
                    'correct': is_correct,
                    'timestamp': match_result.get('timestamp', None)
                })
                
                # 限制历史记录长度
                if len(self.rule_performance[rule_text]['history']) > 200:
                    self.rule_performance[rule_text]['history'] = self.rule_performance[rule_text]['history'][-200:]
        
        # 更新规则权重
        self._update_weights_with_reinforcement_learning()
        
        # 保存性能记录
        self._save_performance_record()
    
    def _update_weights_with_reinforcement_learning(self):
        """
        使用强化学习更新规则权重
        """
        # 实现基于多时间窗口的强化学习更新
        for rule_text, performance in self.rule_performance.items():
            if performance['total'] < 5:  # 数据不足，不更新
                continue
            
            # 获取历史记录
            history = performance['history']
            
            # 计算不同时间窗口的奖励
            time_windows = [5, 20, 100]  # 短期、中期、长期
            rewards = []
            
            for window in time_windows:
                recent_history = history[-window:] if len(history) > window else history
                if not recent_history:
                    continue
                
                correct_count = sum(1 for h in recent_history if h['correct'])
                accuracy = correct_count / len(recent_history)
                
                # 计算奖励（考虑规则类型）
                rule = next((r for r in self.structured_rules if r['raw_text'] == rule_text), None)
                if rule:
                    if rule['type'] == 'strong_prediction':
                        # 强预测规则奖励更高
                        reward = accuracy * 1.2
                    elif rule['type'] == 'strong_warning':
                        # 警告规则奖励适中
                        reward = accuracy * 1.1
                    else:
                        # 普通规则
                        reward = accuracy
                else:
                    reward = accuracy
                
                rewards.append(reward)
            
            if not rewards:
                continue
            
            # 加权平均奖励（近期权重更高）
            weights = [0.5, 0.3, 0.2]  # 时间窗口权重
            if len(rewards) < 3:
                weights = weights[:len(rewards)]
                weights = [w / sum(weights) for w in weights]  # 重新归一化
            
            avg_reward = sum(r * w for r, w in zip(rewards, weights))
            
            # 计算置信度因子（基于数据量）
            confidence_factor = min(1.0, performance['total'] / 50.0)
            
            # 学习率（自适应）
            base_lr = 0.1
            # 根据当前权重调整学习率（权重越高，学习率越低）
            current_weight = self.rule_weights[rule_text]
            lr = base_lr * (1.0 - current_weight * 0.5)
            
            # 正则化项（防止权重过高或过低）
            regularization = 0.01 * (0.7 - current_weight)  # 向0.7靠拢
            
            # 更新权重
            weight_update = lr * (avg_reward - 0.5) + regularization
            new_weight = current_weight + weight_update
            
            # 限制权重范围
            new_weight = max(0.1, min(1.5, new_weight))
            
            # 记录权重变化
            if rule_text not in self.weight_history:
                self.weight_history[rule_text] = []
            
            self.weight_history[rule_text].append({
                'timestamp': self._get_current_timestamp(),
                'old_weight': current_weight,
                'new_weight': new_weight,
                'accuracy': performance['correct'] / performance['total'],
                'total_matches': performance['total'],
                'reward': avg_reward
            })
            
            # 限制历史记录长度
            if len(self.weight_history[rule_text]) > 100:
                self.weight_history[rule_text] = self.weight_history[rule_text][-100:]
            
            # 更新权重
            self.rule_weights[rule_text] = new_weight
        
        # 保存更新后的权重
        self._save_rule_weights()
    
    def _save_performance_record(self):
        """
        保存性能记录
        """
        if not self.rule_performance:
            return
        
        try:
            os.makedirs(os.path.dirname(self.performance_path), exist_ok=True)
            with open(self.performance_path, 'w', encoding='utf-8') as f:
                json.dump(self.rule_performance, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"保存性能记录失败: {e}")
    
    def _get_current_timestamp(self) -> str:
        """
        获取当前时间戳
        
        返回:
            str: 时间戳
        """
        import datetime
        return datetime.datetime.now().isoformat()
    
    def _is_expert_analysis_relevant(self, odds_data: Dict[str, Any], team_state_data: Dict[str, Any]) -> Tuple[bool, float]:
        """
        智能判断专家分析是否与当前比赛相关（改进版：返回相关性评分）
        
        参数:
            odds_data: 赔率数据
            team_state_data: 球队状态数据
            
        返回:
            Tuple[bool, float]: (专家分析是否相关, 相关性评分 0-1)
        """
        # 获取比赛相关数据
        home_win_rate = team_state_data['home_team']['recent_form']['win_rate']
        away_win_rate = team_state_data['away_team']['recent_form']['win_rate']
        win_odds, draw_odds, lose_odds = self._get_representative_odds(odds_data)
        
        # 计算相关性特征
        relevance_features = []
